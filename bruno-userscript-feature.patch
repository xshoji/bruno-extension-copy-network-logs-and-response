diff --git a/packages/bruno-electron/.gitignore b/packages/bruno-electron/.gitignore
index 9faefe7..8567989 100644
--- a/packages/bruno-electron/.gitignore
+++ b/packages/bruno-electron/.gitignore
@@ -10,3 +10,6 @@ sectigo.*
 pnpm-lock.yaml
 package-lock.json
 yarn.lock
+
+# Userscripts directory (local customizations)
+userscripts/
diff --git a/packages/bruno-electron/src/app/apiSpecsWatcher.js b/packages/bruno-electron/src/app/apiSpecsWatcher.js
index b8ce55a..2139ed8 100644
--- a/packages/bruno-electron/src/app/apiSpecsWatcher.js
+++ b/packages/bruno-electron/src/app/apiSpecsWatcher.js
@@ -141,6 +141,20 @@ class ApiSpecWatcher {
       delete this.watcherWorkspaces[watchPath];
     }
   }
+
+  closeAll() {
+    Object.entries(this.watchers).forEach(([watchPath, watcher]) => {
+      if (watcher) {
+        try {
+          watcher.close();
+        } catch (error) {
+          console.error(`Error closing apiSpec watcher for ${watchPath}:`, error);
+        }
+      }
+    });
+    this.watchers = {};
+    this.watcherWorkspaces = {};
+  }
 }
 
 module.exports = ApiSpecWatcher;
diff --git a/packages/bruno-electron/src/app/collection-watcher.js b/packages/bruno-electron/src/app/collection-watcher.js
index 038ba01..863bfb4 100644
--- a/packages/bruno-electron/src/app/collection-watcher.js
+++ b/packages/bruno-electron/src/app/collection-watcher.js
@@ -932,6 +932,20 @@ class CollectionWatcher {
       .filter(([path, watcher]) => !!watcher)
       .map(([path, _watcher]) => path);
   }
+
+  closeAll() {
+    Object.entries(this.watchers).forEach(([watchPath, watcher]) => {
+      if (watcher) {
+        try {
+          watcher.close();
+        } catch (error) {
+          console.error(`Error closing collection watcher for ${watchPath}:`, error);
+        }
+      }
+    });
+    this.watchers = {};
+    this.loadingStates = {};
+  }
 }
 
 const collectionWatcher = new CollectionWatcher();
diff --git a/packages/bruno-electron/src/app/workspace-watcher.js b/packages/bruno-electron/src/app/workspace-watcher.js
index 1cc38c8..7eab927 100644
--- a/packages/bruno-electron/src/app/workspace-watcher.js
+++ b/packages/bruno-electron/src/app/workspace-watcher.js
@@ -224,6 +224,29 @@ class WorkspaceWatcher {
   hasWatcher(workspacePath) {
     return Boolean(this.watchers[workspacePath]);
   }
+
+  closeAll() {
+    Object.entries(this.watchers).forEach(([workspacePath, watcher]) => {
+      if (watcher) {
+        try {
+          watcher.close();
+        } catch (error) {
+          console.error(`Error closing workspace watcher for ${workspacePath}:`, error);
+        }
+      }
+    });
+    Object.entries(this.environmentWatchers).forEach(([workspacePath, watcher]) => {
+      if (watcher) {
+        try {
+          watcher.close();
+        } catch (error) {
+          console.error(`Error closing environment watcher for ${workspacePath}:`, error);
+        }
+      }
+    });
+    this.watchers = {};
+    this.environmentWatchers = {};
+  }
 }
 
 module.exports = WorkspaceWatcher;
diff --git a/packages/bruno-electron/src/index.js b/packages/bruno-electron/src/index.js
index 6cc1979..ddcbe0f 100644
--- a/packages/bruno-electron/src/index.js
+++ b/packages/bruno-electron/src/index.js
@@ -56,6 +56,8 @@ const onboardUser = require('./app/onboarding');
 const SystemMonitor = require('./app/system-monitor');
 const { getIsRunningInRosetta } = require('./utils/arch');
 const { handleAppProtocolUrl, getAppProtocolUrlFromArgv } = require('./utils/deeplink');
+const { createUserscriptsDirectory, getUserscripts, loadScript } = require('./utils/userscripts');
+const dotEnvWatcher = require('./app/dotenv-watcher');
 
 const lastOpenedCollections = new LastOpenedCollections();
 const systemMonitor = new SystemMonitor();
@@ -391,6 +393,45 @@ app.on('ready', async () => {
     mainWindow.webContents.send('main:app-loaded', {
       isRunningInRosetta: getIsRunningInRosetta()
     });
+
+    // Load and execute userscripts
+    try {
+      await createUserscriptsDirectory();
+      const scripts = await getUserscripts();
+
+      for (const script of scripts) {
+        const content = await loadScript(script.path);
+        if (!content) continue;
+
+        try {
+          const wrappedScript = `
+            (function() {
+              if (!window.__userscriptCleanup) {
+                window.__userscriptCleanup = [];
+              }
+              try {
+                const dispose = ${content};
+                if (typeof dispose === 'function') {
+                  window.__userscriptCleanup.push(dispose);
+                }
+              } catch (e) {
+                console.error('Userscript error:', e);
+              }
+            })();
+          `;
+          await mainWindow.webContents.executeJavaScript(wrappedScript);
+          console.log(`Userscript loaded: ${script.name}`);
+        } catch (err) {
+          console.error(`Failed to load userscript: ${script.name}`, err);
+        }
+      }
+
+      if (scripts.length > 0) {
+        console.log(`Loaded ${scripts.length} userscript(s)`);
+      }
+    } catch (err) {
+      console.error('Userscript initialization failed:', err);
+    }
   });
 
   // register all ipc handlers
@@ -407,6 +448,18 @@ app.on('ready', async () => {
 
 // Quit the app once all windows are closed
 app.on('before-quit', () => {
+  // Cleanup userscripts
+  if (mainWindow && !mainWindow.isDestroyed()) {
+    mainWindow.webContents.executeJavaScript(`
+      if (window.__userscriptCleanup) {
+        window.__userscriptCleanup.forEach(fn => {
+          try { fn(); } catch (e) { console.error('Userscript cleanup error:', e); }
+        });
+        window.__userscriptCleanup = [];
+      }
+    `).catch(() => {});
+  }
+
   // Release single instance lock to allow other instances to take over
   if (useSingleInstance && gotTheLock) {
     app.releaseSingleInstanceLock();
@@ -426,6 +479,31 @@ app.on('before-quit', () => {
   } catch (err) {
     console.error('Failed to kill all terminals on quit', err);
   }
+
+  // Close all file watchers to prevent native module cleanup issues
+  try {
+    collectionWatcher.closeAll();
+  } catch (err) {
+    console.error('Failed to close collection watchers on quit', err);
+  }
+
+  try {
+    workspaceWatcher.closeAll();
+  } catch (err) {
+    console.error('Failed to close workspace watchers on quit', err);
+  }
+
+  try {
+    apiSpecWatcher.closeAll();
+  } catch (err) {
+    console.error('Failed to close apiSpec watchers on quit', err);
+  }
+
+  try {
+    dotEnvWatcher.closeAll();
+  } catch (err) {
+    console.error('Failed to close dotEnv watchers on quit', err);
+  }
 });
 
 app.on('window-all-closed', app.quit);
diff --git a/packages/bruno-electron/src/utils/userscripts.js b/packages/bruno-electron/src/utils/userscripts.js
new file mode 100644
index 0000000..13c0758
--- /dev/null
+++ b/packages/bruno-electron/src/utils/userscripts.js
@@ -0,0 +1,74 @@
+const fsPromises = require('fs').promises;
+const path = require('path');
+const { app } = require('electron');
+const { exists } = require('./filesystem');
+const isDev = require('electron-is-dev');
+
+/**
+ * Get the userscripts directory path
+ * Development: ./userscripts
+ * Production: ~/Library/Application Support/bruno/userscripts (macOS)
+ */
+const getUserscriptsDirectory = () => {
+  if (isDev) {
+    return path.join(process.cwd(), 'userscripts');
+  }
+  return path.join(app.getPath('userData'), 'userscripts');
+};
+
+/**
+ * Create the userscripts directory if it doesn't exist
+ */
+const createUserscriptsDirectory = async () => {
+  const dir = getUserscriptsDirectory();
+  await fsPromises.mkdir(dir, { recursive: true });
+  return dir;
+};
+
+/**
+ * Get all userscript files from the userscripts directory
+ * Returns sorted list for predictable execution order
+ */
+const getUserscripts = async () => {
+  const dir = getUserscriptsDirectory();
+  if (!(await exists(dir))) {
+    return [];
+  }
+
+  try {
+    const files = await fsPromises.readdir(dir);
+    return files
+      .filter((file) => file.endsWith('.js'))
+      .sort()
+      .map((file) => ({
+        name: file,
+        path: path.join(dir, file)
+      }));
+  } catch (error) {
+    console.error('Failed to read userscripts directory:', error);
+    return [];
+  }
+};
+
+/**
+ * Load script content from file
+ */
+const loadScript = async (scriptPath) => {
+  if (!(await exists(scriptPath))) {
+    return null;
+  }
+
+  try {
+    return await fsPromises.readFile(scriptPath, 'utf8');
+  } catch (error) {
+    console.error(`Failed to read script: ${scriptPath}`, error);
+    return null;
+  }
+};
+
+module.exports = {
+  getUserscriptsDirectory,
+  createUserscriptsDirectory,
+  getUserscripts,
+  loadScript
+};
